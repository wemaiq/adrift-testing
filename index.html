<!DOCTYPE html>
<html lang="en"><head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Figtree:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Dongle&display=swap" rel="stylesheet">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>adrift</title>

<!-- Favicons -->
<link rel="icon" type="image/svg+xml" sizes="16x16" href="favicon-adrift-16x16.svg">
<link rel="icon" type="image/svg+xml" sizes="32x32" href="favicon-adrift-32x32.svg">
<link rel="shortcut icon" href="favicon-adrift-32x32.svg" type="image/svg+xml">

<style>
  :root{
    --paper-edge: #e8e3da;
    --paper-face: #e8e3da;
    --bloom-a: rgba(220, 211, 199, 0.40);
    --bloom-b: rgba(220, 211, 199, 0.40);
  }

  html, body { height:100%; }
  body { margin:0; background:#000; overflow:hidden; font-family: ui-sans-serif, system-ui; color:#ececed; }
  canvas { display:block; width:100%; height:100%; }

  /* Intro overlay */
  #intro-overlay {
    position: fixed;
    inset: 0;
    background: #000;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    opacity: 1;
    transition: opacity 1s ease-out;
    pointer-events: all;
  }
  
  #intro-overlay.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  
  #intro-text {
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    color: rgba(236, 236, 237, 0.85);
    text-align: center;
    max-width: 500px;
    opacity: 0;
    animation: fadeInText 2s ease-in forwards;
    font-weight: 300;
    letter-spacing: 0.02em;
  }
  
  #intro-text.fade-out-text {
    animation: fadeOutText 1.5s ease-out forwards;
  }
  
  @keyframes fadeInText { to { opacity: 1; } }
  @keyframes fadeOutText { to { opacity: 0; } }
  @keyframes fadeInCounter { to { opacity: 1; } }

  /* Initially hide main content */
  .main-content { opacity: 0; transition: opacity 1.5s ease-in; }
  .main-content.visible { opacity: 1; }

  /* Layering: rain over boats (click-through), boats under notes */
  #rain  { position:fixed; inset:0; z-index:2; pointer-events:none; }
  #canvas{ position:fixed; inset:0; z-index:1; }

  header{ font-weight:400; position:fixed; top:18px; left:50%; transform:translateX(-50%); letter-spacing:0.25em; font-size:20px; font-family:"Dongle", ui-sans-serif, system-ui, sans-serif;text-transform:uppercase; text-align:center; user-select:none; z-index:5; }
  .hint{ font-weight:400; position:fixed; left:20px; bottom:16px; color:#9aa0a8; font-size:12px; opacity:.7; user-select:none; background: rgba(255,255,255,.03); letter-spacing: 0.05em; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.06); backdrop-filter: blur(3px); z-index:5; }

  /* Sound toggle */
  .sound-toggle{
    position:fixed; right:20px; bottom:16px; z-index:5;
    background: rgba(255,255,255,.03);
    color:#9aa0a8; font-size:12px; line-height:1;
    padding:8px 10px; border-radius:10px;
    border:1px solid rgba(255,255,255,.06);
    backdrop-filter: blur(3px);
    cursor:pointer; user-select:none;
    letter-spacing: 0.05em;
  }
  .sound-toggle.active{ color:#ececed; border-color: rgba(255,255,255,.12); }
  .sound-toggle:focus-visible{ outline:2px solid rgba(255, 200, 100, 0.25); outline-offset:2px; }

  /* Center-bottom CTA (kept) */
  .cta-btn{ 
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px; z-index:5;
    padding:28px 36px; border-radius:9999px; font-size:13px; line-height:1; color:#fff;
    letter-spacing: 0.05em;
    border:1px solid rgba(255,255,255,.28);
    background: rgba(255,255,255,.04);
    backdrop-filter: blur(3px);
    transition: box-shadow .25s ease, transform .2s ease, border-color .25s ease, background .25s ease;
    cursor:pointer; user-select:none;
  }
  .cta-btn:hover{ box-shadow: 0 0 36px 12px rgba(255, 219, 90, 0.174), 0 0 8px 2px rgba(255,255,255,.25); border-color: rgba(255,255,255,.5); }
  .cta-btn:focus-visible{ outline:2px solid rgba(255, 200, 100, 0.35); outline-offset:3px; }

  /* Hidden media */
  #boatVideo, #bgAudio { position: fixed; left:-9999px; top:-9999px; width:1px; height:1px; opacity:0; pointer-events:none; }

  /* ===========================================================
     Unfolding NOTE (used for both boat view + composer)
     =========================================================== */
  .note-overlay { position: fixed; inset:0; z-index:6; pointer-events:none; }
  .overlay-close { position:fixed; inset:0; background: transparent; pointer-events:auto; }

  .note{
    position:absolute;
    width: min(350px, 90vw); 
    height: min(350px, 90vw);
    transform-style: preserve-3d; perspective: 800px;
    pointer-events:auto;
    filter: drop-shadow(0 12px 40px rgba(0,0,0,.55));
    transition: transform .35s ease, opacity .25s ease;
    cursor: grab;
    user-select: none; touch-action: none;
    will-change: left, top, opacity, transform;
    background: transparent;
  }
  .note.dragging{ cursor: grabbing; }
  .note.closing{ opacity:0; transform: scale(.98) translateZ(0); pointer-events:none; }

  /* FIXED: Circle close button for mobile */
  .note-close{
    position:absolute; top:10px; right:10px;
    width:28px; height:28px;
    border-radius:50%;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(12,14,18,.65);
    color:#fff; font-size:16px; line-height:1;
    border:1px solid rgba(255,255,255,.18);
    box-shadow:none;
    cursor:pointer;
    opacity:0; 
    pointer-events:none;
    transition: opacity .25s ease, transform .20s ease, background .2s ease, border-color .2s ease;
    z-index:3;
    -webkit-appearance: none; -moz-appearance: none; appearance: none;
    padding: 0; box-sizing: border-box; overflow: hidden; text-align: center;
    transform: scale(.92) translateZ(0);
    -webkit-transform: scale(.92) translateZ(0);
  }
  .note.unfold .note-close{
    opacity:1; transform: scale(1) translateZ(0);
    transition-delay: 1.25s, 1.25s, 0s, 0s;
    pointer-events:auto;
  }
  .note-close:hover{ transform: scale(1.06) translateZ(0); background: rgba(12,14,18,.78); border-color: rgba(255,255,255,.28); }
  .note-close:active{ transform: scale(.98) translateZ(0); }
  .note-close:focus-visible{ outline:2px solid rgba(255, 180, 60, 0.5); outline-offset:2px; }

  .note-stage, .note-frame { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); width:100%; height:100%; }
  .note-frame{ opacity:0; box-shadow: 0 0 40px rgba(0,0,0,0.06); animation: note-show 0.5s 1s ease forwards; }

  .note-box{
    position:absolute;
    width:calc(50% - 25px); height:calc(50% - 25px);
    background: var(--paper-face);
    border: 25px solid var(--paper-edge);
    box-shadow: 0 0 40px rgba(0,0,0,0.07);
    overflow:hidden; border-radius:4px;
  }
  .note-box .note-in{
    position:absolute; width:100px; height:100px; border-radius:50%;
    background: transparent !important;
    animation: note-grow 0.5s 3s cubic-bezier(0.66,-0.30,0.66,1) forwards;
  }
  .note-box .one{ left:100px; bottom:-50px; }
  .note-box .two{ left:-50px;  bottom:-50px; }
  .note-box .thr{ left:100px; bottom:100px; }
  .note-box .fou{ left:-50px;  bottom:100px; }

  .note-box:nth-child(1){ border-right:none; border-bottom:none; border-radius: 5px 0 0 0; animation: note-clr 0.5s 0.5s ease forwards; }
  .note-box:nth-child(2){ left:50%; border-left:none; border-bottom:none; border-radius: 0 5px 0 0; transform-origin: 0 0; transform: rotateY(180deg); animation: note-fold 0.5s 0.5s ease forwards; }
  .note-box:nth-child(3){ top:50%; opacity:0; border-top:none; border-right:none; border-radius: 0 0 0 5px; transform: rotateX(180deg); transform-origin: 0 0; animation: note-fold2 0.5s 1s ease forwards; }
  .note-box:nth-child(4){ top:50%; left:50%; opacity:0; border-top:none; border-left:none; border-radius: 0 0 5px 0; transform: rotateX(180deg); transform-origin: 0 0; animation: note-fold2 0.5s 1s ease forwards; }

  .note-content{
    position:absolute; inset:22px 24px;
    display:flex; flex-direction:column; justify-content:flex-start;
    color:#0e1520; opacity:0; transform: translateY(4px);
    transition: opacity .45s ease 1.2s, transform .45s ease 1.2s;
    font-synthesis-weight:none;
    padding: 0;
    background: transparent;
  }
  .note.unfold .note-content{ opacity:1; transform: translateY(0); }

  .note-title{ font-size:11px; letter-spacing:.12em; text-transform:uppercase; color:#4c5562; margin-bottom:10px; }
  .note-text{ font-size:20px; line-height:1.55; color:#10151c; }
  .note-meta{ margin-top:14px; font-size:12px; color:#5a6472; }

  @keyframes note-clr { 0%, 100% { background: var(--paper-face); } }
  @keyframes note-fold { 0%, 99.99% { background: var(--paper-face); } 100% { background: var(--paper-face); transform: rotateY(360deg); } }
  @keyframes note-fold2 { 0%{opacity:1;background:var(--paper-face);} 25%{opacity:1} 40%{opacity:1} 100%{opacity:1;background:var(--paper-face);transform: rotateX(0deg);} }
  @keyframes note-show { to { opacity:1; } }

  /* Composer form bits */
  .compose-field{ width:100%; min-height:110px; resize:vertical; box-sizing:border-box; border-radius:8px; border:1px solid rgba(0,0,0,.1); padding:10px 12px; font: 16px/1.5 ui-sans-serif, system-ui; color:#0e1520; background:#fff; }
  .compose-field:focus { outline: none; border-color: rgba(7, 7, 7, 0.4); box-shadow: 0 0 0 1px rgba(255, 180, 60, 0.15); }
  .compose-foot{ display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:12px; color:#4c5562; }
  .pill-btn{ padding:12px 18px; border-radius:999px; border:1px solid rgba(0,0,0,.12); background:#0f172a; color:#fff; cursor:pointer; }
  .pill-btn:focus-visible { outline: 2px solid rgba(255, 180, 60, 0.5); outline-offset: 2px; }

  .note .compose-field { touch-action: auto; user-select: text; }
  .note .compose-foot button { touch-action: auto; }

  html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-rendering: optimizeLegibility; }
  .figtree-adrift { font-family: "Figtree", ui-sans-serif, system-ui, sans-serif; font-optical-sizing: auto; font-weight: 600; font-style: normal; }
  .dongle-regular { font-family: "Dongle", sans-serif; font-weight: 400; font-style: normal; }

  .ripple > * { display: inline-block; text-shadow: 0 0 0 #fff; color: transparent; }
  @keyframes rippleEffect {
    40% { opacity: .35; }
    50% { transform: translate3d(.5em, 0, 0) scale(1.1); text-shadow: 0 0 20px #fff; }
    75% { transform: translate3d(0, 0, 0) scale(1); text-shadow: 0 0 0 #fff; opacity: 1; }
  }

  header.ripple span.figtree-adrift { font-family: "Figtree", ui-sans-serif, system-ui, sans-serif; font-weight: 700; }

  /* Mobile responsive styles */
  @media (max-width: 640px) {
    #intro-text { font-size: 14px; max-width: 85vw; }
    .note-content { inset: 21px 18px 16px 18px; }
    .note-text { font-size: 18px; }
    .note-title { font-size: 10px; }
    .note-meta { font-size: 11px; }
    .cta-btn { padding: 20px 28px; font-size: 12px; bottom: 70px; }
    header { font-size: 18px; }

    .note-close {
      top: 6px; width: 32px; height: 32px; font-size: 18px;
      min-width: 32px; min-height: 32px; max-width: 32px; max-height: 32px;
      display: flex; align-items: center; justify-content: center; line-height: 1;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif; padding-bottom: 1px;
    }
  }

  /* Landscape mobile */
  @media (max-height: 500px) and (orientation: landscape) {
    .hint { left: 10px; bottom: 10px;}
    .sound-toggle { right: 10px; bottom: 10px; }
    .cta-btn { bottom: 16px; padding: 16px 24px; }
    header { top: 10px; }
  }

  /* Hi-DPI */
  @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    .note-close { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; backface-visibility: hidden; transform-style: flat; }
  }
</style>
</head>
<body class="figtree-adrift">
  <!-- Intro overlay -->
 <div id="intro-overlay">
    <div id="intro-text">
      <span>Doubt is universal, yet deeply personal. It comes and goes like waves, like passing weather. Never the sky, never the sea. And when it fades, the stillness of being remains.</span>
      <div id="doubt-counter" style="margin-top: 20px; font-size: 12px; color: rgba(236, 236, 237, 0.5); opacity: 0; animation: fadeInCounter 2s ease-in 3s forwards;">— doubts released</div>
    </div>
  </div>

  <!-- Main content wrapper -->
  <div class="main-content">
    <header class="ripple"><span><span>a</span><span>d</span><span>r</span><span>i</span><span>f</span><span>t</span></span></header>

    <!-- media -->
    <video id="boatVideo" src="boat.mp4" loop muted playsinline preload="auto"></video>
    <audio id="bgAudio" src="sound.mp3" loop preload="auto"></audio>

    <!-- layers -->
    <canvas id="rain" aria-hidden="true"></canvas>
    <canvas id="canvas"></canvas>

    <div class="hint">Click boat to unfold</div>
    <button id="soundToggle" class="sound-toggle" aria-pressed="false" aria-label="Enable sound">Sound: Off</button>
    <button id="releaseBtn" class="cta-btn" aria-label="Release your doubt">Release your doubt</button>
  </div>

  <script src="./rain.js" defer></script>

<script>
  /* =====================
     Intro sequence
     ===================== */
  const introOverlay = document.getElementById('intro-overlay');
  const introText = document.getElementById('intro-text');
  const mainContent = document.querySelector('.main-content');
  
  setTimeout(() => {
    introText.classList.add('fade-out-text');
    setTimeout(() => {
      introOverlay.classList.add('fade-out');
      mainContent.classList.add('visible');
      setTimeout(() => { introOverlay.remove(); }, 2000);
    }, 500);
  }, 8000);

  /* =====================
     Supabase config (READ)
     ===================== */
  const SUPABASE_URL  = 'https://lrjpntpvcgzjhowrlmit.supabase.co';
  const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxyanBudHB2Y2d6amhvd3JsbWl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY0OTk4ODcsImV4cCI6MjA3MjA3NTg4N30.sDdezusu8bp6lBp6hmU6QnJVIz0Et4VHp5giEpUTa40';

  async function fetchApprovedDoubts(limit = 500) {
    const url = `${SUPABASE_URL}/rest/v1/doubts?select=id,doubt,created_at&approved=is.true&order=created_at.desc&limit=${limit}`;
    const res = await fetch(url, {
      headers: { apikey: SUPABASE_ANON, Authorization: `Bearer ${SUPABASE_ANON}`, Accept: 'application/json' }
    });
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error(`Supabase fetch failed (${res.status}) ${text}`);
    }
    const rows = await res.json();
    return rows.map(r => ({
      id: r.id, text: r.doubt ?? '', date: (r.created_at || new Date().toISOString()).slice(0,10)
    })).filter(d => d.text && d.text.trim().length);
  }

  async function fetchTotalDoubts() {
    const url = `${SUPABASE_URL}/rest/v1/doubts?select=count&approved=is.true`;
    const res = await fetch(url, {
      headers: { apikey: SUPABASE_ANON, Authorization: `Bearer ${SUPABASE_ANON}`, Accept: 'application/json', Prefer: 'count=exact' }
    });
    if (!res.ok) return 0;
    return parseInt(res.headers.get('Content-Range')?.split('/')[1] || '0');
  }

  /* ---------- n8n webhook ---------- */
  const N8N_WEBHOOK_URL = 'https://alexmiretski.app.n8n.cloud/webhook/release-doubt';

  async function postDoubtToN8N(text){
    const res = await fetch(N8N_WEBHOOK_URL, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text })
    });
    let data = {}; try { data = await res.json(); } catch(e) {}
    if (!res.ok || data?.ok === false) {
      const msg = data?.error || `Request failed (${res.status})`;
      throw new Error(msg);
    }
    const d = Array.isArray(data) ? data[0] : data;
    return { id: d.id, created_at: d.created_at, doubt: d.doubt ?? text };
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha:true });
  const boatVideo = document.getElementById('boatVideo');
  const bgAudio = document.getElementById('bgAudio');
  const soundToggle = document.getElementById('soundToggle');
  const releaseBtn = document.getElementById('releaseBtn');

  let W, H;
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    W = innerWidth;  H = innerHeight;           // CSS pixels
    canvas.width = W * dpr; canvas.height = H * dpr;
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);     // crisp drawing in CSS px
  }
  addEventListener('resize', resize);
  resize();

  /* ====== Media autoplay ====== */
  const DEFAULT_VOL = 0.28;
  function startAudio(){ bgAudio.volume = DEFAULT_VOL; bgAudio.play().then(()=> updateSoundUI(true)).catch(()=>{}); }
  function updateSoundUI(on){ soundToggle.classList.toggle('active', !!on); soundToggle.setAttribute('aria-pressed', on ? 'true' : 'false'); soundToggle.textContent = on ? 'Sound: On' : 'Sound: Off'; }

  let videoReady = false;
  let videoRestartAttempts = 0;
  const MAX_RESTART_ATTEMPTS = 2;

  boatVideo.addEventListener('canplay', () => { 
    videoReady = true; 
    if(boatVideo.paused) boatVideo.play().catch(() => {}); 
  }, {once: true});

  function checkAndRestartVideo() {
    if (!videoReady && videoRestartAttempts < MAX_RESTART_ATTEMPTS) {
      console.warn(`Video not ready after timeout, attempting restart ${videoRestartAttempts + 1}/${MAX_RESTART_ATTEMPTS}`);
      videoRestartAttempts++;
      const currentSrc = boatVideo.src;
      boatVideo.src = ''; boatVideo.load();
      boatVideo.src = currentSrc + '?t=' + Date.now();
      setTimeout(() => {
        boatVideo.play().catch(() => { console.error('Video restart failed'); });
      }, 500);
      if (videoRestartAttempts < MAX_RESTART_ATTEMPTS) setTimeout(checkAndRestartVideo, 8000);
    }
  }

  boatVideo.play().catch(() => {});
  setTimeout(() => { if (!videoReady) checkAndRestartVideo(); }, 15000);

  const ensurePlay = () => { 
    if (!videoReady) { console.log('User interaction - forcing video restart'); checkAndRestartVideo(); }
    boatVideo.play().catch(() => {}); startAudio(); 
  };
  addEventListener('pointerdown', ensurePlay, {once:true}); 
  addEventListener('keydown', ensurePlay, {once:true});
  soundToggle.addEventListener('click', ()=>{ if(bgAudio.paused){ startAudio(); } else { bgAudio.pause(); updateSoundUI(false); } });
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden && !bgAudio.paused){ bgAudio.play().catch(()=>{}); } });

  /* ===== Boats ===== */
  const CROP = {x:0, y:0, w:1, h:1};
  const BOAT_COUNT = window.innerWidth <= 640 ? 8 : 11;
  const BOAT_HEIGHT = 170;          // bigger base size
  const SPEED_X=0.10, BOB_AMPL=12, BOB_FREQ=0.0016;
  const COLLISION_PAD = 15, PUSH_STRENGTH = 0.02, FRICTION = 0.34;

  // Perspective scaling range (top -> bottom)
  const PERSPECTIVE_MIN = 0.60;     // size at top
  const PERSPECTIVE_MAX = 1.35;     // size at bottom

  // Holds fetched approved doubts and session tracking
  let APPROVED_DOUBTS = [];
  let USED_DOUBT_IDS = new Set();
  let SHUFFLED_DOUBTS = [];

  function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  function initializeDoubtPool() {
    SHUFFLED_DOUBTS = shuffleArray(APPROVED_DOUBTS);
    USED_DOUBT_IDS.clear();
    console.log('Initialized shuffled doubt pool:', SHUFFLED_DOUBTS.length, 'doubts');
  }

  function pickRandomDoubt() {
    if (APPROVED_DOUBTS.length === 0) {
      return { text: "…", date: new Date().toISOString().slice(0,10), id: "placeholder" };
    }
    if (USED_DOUBT_IDS.size >= APPROVED_DOUBTS.length) {
      console.log('All doubts used, reshuffling pool');
      initializeDoubtPool();
    }
    let selected = null;
    for (const d of SHUFFLED_DOUBTS) {
      if (!USED_DOUBT_IDS.has(d.id)) { selected = d; USED_DOUBT_IDS.add(d.id); break; }
    }
    if (!selected) { selected = SHUFFLED_DOUBTS[0]; USED_DOUBT_IDS.add(selected.id); }
    return selected;
  }

  async function refreshDoubtPool() {
    try {
      const fresh = await fetchApprovedDoubts(600);
      if (fresh.length > 0) {
        const old = APPROVED_DOUBTS.length;
        APPROVED_DOUBTS = fresh;
        if (fresh.length > old * 1.2) {
          initializeDoubtPool();
          console.log('Refreshed and reshuffled doubt pool:', APPROVED_DOUBTS.length, 'doubts');
        } else {
          console.log('Refreshed doubt pool:', APPROVED_DOUBTS.length, 'doubts');
        }
      }
    } catch (err) { console.error('Failed to refresh doubts:', err); }
  }

  class Boat{
    constructor(){ this.reset(true); }
    reset(initial = false) {
      this.yBase = Math.random() * H * 0.75 + H * 0.1;
      this.x = initial ? Math.random() * W : -(this._w || 160) - 30;
      this.phase = Math.random() * Math.PI * 2;
      this.alpha = 0.95;
      this.doubt = pickRandomDoubt();
      this._h = BOAT_HEIGHT;
      this._w = BOAT_HEIGHT * 1.8;
      this.vx = 0; this.vy = 0;
      this.highlightUntil = 0;
      this.paused = false;
      this.morphingIn = false;
      this.morphingOut = false;
      this.morphT0 = 0;
    }
    update(t, boats){
      const canMove = !(this.morphingOut);
      if(canMove){ 
        this.x += SPEED_X + this.vx; 
        if(this.x > W + (this._w||160)) this.reset(false); 
      }
      const bob = Math.sin(this.phase + t*BOB_FREQ) * BOB_AMPL; 
      this.y = this.yBase + bob + this.vy;

      const w = this._w || (BOAT_HEIGHT*1.8), h = this._h || BOAT_HEIGHT;
      for(const other of boats){
        if(other === this) continue;
        const ow = other._w || (BOAT_HEIGHT*1.8), oh = other._h || BOAT_HEIGHT;
        const halfW = w*0.5 + COLLISION_PAD, halfH = h*0.5 + COLLISION_PAD;
        const otherHalfW = ow*0.5 + COLLISION_PAD, otherHalfH = oh*0.5 + COLLISION_PAD;
        const dx = this.x - other.x, dy = this.y - other.y;
        const overlapX = (halfW + otherHalfW) - Math.abs(dx);
        const overlapY = (halfH + otherHalfH) - Math.abs(dy);
        if(overlapX > 0 && overlapY > 0){
          if(overlapX < overlapY){ 
            const dirX = Math.sign(dx) || (Math.random()<0.5 ? 1 : -1); 
            this.vx += dirX * overlapX * PUSH_STRENGTH; 
          } else { 
            const dirY = Math.sign(dy) || (Math.random()<0.5 ? 1 : -1); 
            this.vy += dirY * overlapY * PUSH_STRENGTH; 
          }
        }
      }
      this.vx *= FRICTION; 
      this.vy *= FRICTION;
    }
    draw(now){
      if(!videoReady) return;

      // Source (keep aspect ratio perfect)
      const vW=boatVideo.videoWidth||640, vH=boatVideo.videoHeight||360;
      const srcW=vW*CROP.w, srcH=vH*CROP.h, srcX=vW*CROP.x, srcY=vH*CROP.y;

      // Perspective: map y (0..H) -> scale (min..max)
      const t = Math.max(0, Math.min(1, this.y / H)); // 0 top, 1 bottom
      const scale = PERSPECTIVE_MIN + (PERSPECTIVE_MAX - PERSPECTIVE_MIN) * t;

      const displayH = BOAT_HEIGHT * scale;
      const displayW = displayH * (srcW/srcH); // maintain ratio
      this._w = displayW; this._h = displayH;

      // Opacity falls off with distance (smaller boats lighter)
      let a = this.alpha;
      if(this.morphingOut) a = 0;
      else a *= (0.35 + 0.65 * t); // 0.35 at top -> ~1 at bottom

      if(a <= 0.01) return;

      ctx.save();
      ctx.translate(this.x, this.y);

      if(this.highlightUntil){
        const remaining = this.highlightUntil - performance.now();
        if(remaining > 0){
          const duration = 6000;
          const tFrac = Math.max(0, remaining/duration);
          const fade = 1 - (1 - tFrac) * (1 - tFrac);
          ctx.save();
          ctx.globalAlpha = fade;
          const g = ctx.createRadialGradient(0,0,10, 0,0,220);
          g.addColorStop(0,'rgba(255,240,160,.35)');
          g.addColorStop(0.35,'rgba(255,210,100,.18)');
          g.addColorStop(1,'rgba(255,210,100,0)');
          ctx.globalCompositeOperation='screen';
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2); ctx.fill();
          ctx.restore();
        } else {
          this.highlightUntil = 0;
        }
      }

      ctx.globalAlpha = a;

      // iOS blend mode fix
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      if(isIOS) {
        const dpr = window.devicePixelRatio || 1;
        const off = document.createElement('canvas');
        off.width = displayW * dpr; off.height = displayH * dpr;
        const octx = off.getContext('2d');
        octx.setTransform(dpr,0,0,dpr,0,0);
        octx.drawImage(boatVideo, srcX, srcY, srcW, srcH, 0, 0, displayW, displayH);
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(off, -displayW/2, -displayH/2, displayW, displayH);
        ctx.globalCompositeOperation = 'source-over';
      } else {
        const prev = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(boatVideo, srcX,srcY,srcW,srcH, -displayW/2, -displayH/2, displayW, displayH);
        ctx.globalCompositeOperation = prev;
      }

      ctx.restore();
    }
    hit(mx,my){ 
      return mx>=this.x-this._w/2 && mx<=this.x+this._w/2 && 
             my>=this.y-this._h/2 && my<=this.y+this._h/2; 
    }
  }

  // Will be filled after Supabase fetch
  let boats = [];

  // Periodic refresh every 5 minutes
  setInterval(refreshDoubtPool, 5 * 60 * 1000);

  /* ===== Unfolding NOTE factory (boat + composer) ===== */
  let overlay=null, noteEl=null, noteBoat=null, noteClosing=false, composerOpen=false;

  const NO_DRAG_SELECTOR = 'textarea, input, select, button, a, [contenteditable="true"], .compose-field, .pill-btn, .note-close';

  function makeDraggable(el, size){
    let dragging=false, startX=0, startY=0, startLeft=0, startTop=0;
    const clamp=(v,min,max)=>Math.max(min, Math.min(max, v));

    el.addEventListener('pointerdown', (e)=>{
      if(e.button && e.button !== 0) return;
      if (e.target.closest(NO_DRAG_SELECTOR)) return;
      dragging = true;
      el.classList.add('dragging');
      el.setPointerCapture(e.pointerId);
      startX = e.clientX; startY = e.clientY;
      startLeft = parseFloat(el.style.left)||0;
      startTop  = parseFloat(el.style.top)||0;
      e.preventDefault();
    });

    el.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      let nextLeft = startLeft + dx, nextTop  = startTop  + dy;
      const maxL = innerWidth  - size, maxT = innerHeight - size;
      nextLeft = clamp(nextLeft, 0, Math.max(0, maxL));
      nextTop  = clamp(nextTop , 0, Math.max(0, maxT));
      el.style.left = nextLeft + 'px';
      el.style.top  = nextTop  + 'px';
    });

    const endDrag=(e)=>{
      if(!dragging) return;
      dragging = false;
      el.classList.remove('dragging');
      try{ el.releasePointerCapture(e.pointerId); }catch(_){}
    };
    el.addEventListener('pointerup', endDrag);
    el.addEventListener('pointercancel', endDrag);
    el.addEventListener('lostpointercapture', ()=>{ dragging=false; el.classList.remove('dragging'); });
  }

  function createNote({ x = null, y = null, title, bodyHTML, metaHTML, boat = null, startScale = 0.72 }) {
    overlay = document.createElement('div');
    overlay.className = 'note-overlay';
    overlay.innerHTML = `<div class="overlay-close" aria-hidden="true"></div>`;
    document.body.appendChild(overlay);

    noteEl = document.createElement('div');
    noteEl.className = 'note';

    const maxSize = Math.min(350, window.innerWidth * 0.9);
    const size = maxSize;
    const posX = (x ?? innerWidth / 2) - size / 2;
    const posY = (y ?? innerHeight / 2) - size / 2;

    noteEl.style.left = `${posX}px`;
    noteEl.style.top = `${posY}px`;
    noteEl.style.width = `${size}px`;
    noteEl.style.height = `${size}px`;
    noteEl.style.transformOrigin = 'center center';
    noteEl.style.transform = `scale(${startScale}) translateZ(0)`;

    const stage = document.createElement('div'); stage.className = 'note-stage';
    const frame = document.createElement('div'); frame.className = 'note-frame';
    noteEl.append(stage, frame);

    function makeBox(circleClass){
      const b = document.createElement('div'); b.className = 'note-box';
      const i = document.createElement('div'); i.className = 'note-in ' + circleClass;
      b.appendChild(i);
      return b;
    }
    stage.append(makeBox('one'), makeBox('two'), makeBox('thr'), makeBox('fou'));

    const content = document.createElement('div'); content.className='note-content';
    content.innerHTML = `
      <div class="note-title">${title}</div>
      ${bodyHTML}
      ${metaHTML||''}
    `;
    noteEl.appendChild(content);

    const closeBtn = document.createElement('button');
    closeBtn.className = 'note-close';
    closeBtn.setAttribute('aria-label','Close note');
    closeBtn.innerHTML = '&times;';
    closeBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
    closeBtn.addEventListener('click', (e)=>{ e.stopPropagation(); closeNote(); });
    closeBtn.addEventListener('transitionend', (e)=>{
      if(e.propertyName === 'opacity' && getComputedStyle(closeBtn).opacity === '1'){
        closeBtn.style.pointerEvents = 'auto';
      }
    });
    noteEl.appendChild(closeBtn);

    overlay.appendChild(noteEl);
    noteBoat = boat || null;

    makeDraggable(noteEl, size);

    requestAnimationFrame(()=>{
      noteEl.style.transform = 'scale(1) translateZ(0)';
      setTimeout(()=> noteEl.classList.add('unfold'), 140);
    });

    overlay.querySelector('.overlay-close').addEventListener('click', closeNote, {once:true});
  }

  function closeNote(){
    if(!noteEl || noteClosing) return;
    noteClosing = true;

    if(noteBoat){
      noteBoat.morphingIn = false;
      // let the boat keep floating
    }

    noteEl.classList.add('closing');

    const FINISH = ()=> {
      overlay?.remove(); overlay=null; noteEl=null;
      noteBoat = null; noteClosing = false; composerOpen = false;
    };

    let done=false;
    noteEl.addEventListener('transitionend', (e)=>{
      if(done || e.propertyName !== 'opacity') return;
      done=true; FINISH();
    }, {once:true});
    setTimeout(()=>{ if(!done) FINISH(); }, 280);
  }

  function openNoteFromBoat(boat){
    boat.morphingIn = true;
    boat.morphT0 = performance.now();
    const meta = `<div class="note-meta">${new Date(boat.doubt.date+'T00:00:00').toLocaleDateString(undefined,{year:'numeric',month:'long',day:'numeric'})}</div>`;
    const body = `<div class="note-text">${boat.doubt.text}</div>`;
    const maxSize = Math.min(350, window.innerWidth * 0.9);
    const isMobile = window.innerWidth <= 640;
    const noteX = isMobile ? innerWidth / 2 : boat.x;
    const noteY = isMobile ? innerHeight / 2 : boat.y;
    createNote({ x:noteX, y:noteY, title:'Anonymous Doubt', bodyHTML:body, metaHTML:meta, boat, startScale:(boat._h/maxSize)*0.9 });
  }

  /* CTA → composer note */
  function openComposerNote() {
    composerOpen = true;

    const body = `
      <textarea class="compose-field" id="doubtInput" maxlength="200" placeholder="Type your doubt (200 characters max)"></textarea>
      <div class="compose-foot">
        <div><span id="charCount">0</span>/200</div>
        <button class="pill-btn" id="submitDoubt" type="button">Release</button>
      </div>
    `;

    createNote({
      x: innerWidth / 2,
      y: innerHeight / 2,
      title: 'Release your doubt',
      bodyHTML: body,
      metaHTML: '',
      boat: null,
      startScale: 0.72
    });

    const input = document.getElementById('doubtInput');
    const count = document.getElementById('charCount');
    const submit = document.getElementById('submitDoubt');

    input.addEventListener('input', () => { count.textContent = input.value.length; });
    setTimeout(() => input.focus(), 50);

    async function doRelease() {
      const text = (input.value || '').trim();
      if (!text) { input.focus(); return; }

      submit.disabled = true;
      const prev = submit.textContent;
      submit.textContent = 'Releasing…';

      try {
        const { id, created_at, doubt } = await postDoubtToN8N(text);
        const b = new Boat();
        b.doubt = { text: doubt, date: (created_at || new Date().toISOString()).slice(0, 10), id };
        b.x = innerWidth / 2; b.yBase = innerHeight / 2; b.phase = 0;
        b.highlightUntil = performance.now() + 6000;
        boats.push(b);
        closeNote();
      } catch (err) {
        console.error('Release failed:', err);
        alert(err.message || 'Failed to release your doubt.');
      } finally {
        submit.disabled = false; submit.textContent = prev;
      }
    }

    submit.addEventListener('click', doRelease);
    input.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') { e.preventDefault(); doRelease(); }
    });
  }

  /* Loop */
  function animate(now=0){ 
    ctx.clearRect(0,0,W,H); 
    for(const b of boats){ b.update(now, boats); b.draw(now); } 
    requestAnimationFrame(animate); 
  }
  animate();

  /* Interactions */
  canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    let overBoat = false;
    for(const b of boats){ if(b.hit(mx,my) && !b.morphingOut){ overBoat = true; break; } }
    canvas.style.cursor = overBoat ? 'pointer' : 'default';
  });
  
  canvas.addEventListener('click', e=>{
    if(composerOpen) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    for(const b of boats){ 
      if(b.hit(mx,my)){ if(b.morphingOut) return; openNoteFromBoat(b); break; } 
    }
  });
  releaseBtn.addEventListener('click', openComposerNote);
  addEventListener('keydown', e=>{ if(e.key==='Escape'){ closeNote(); } });

  /* =========
     Boot flow
     ========= */
  (async function init(){
    try{
      APPROVED_DOUBTS = await fetchApprovedDoubts(600);
      if (APPROVED_DOUBTS.length === 0) {
        console.warn('No approved doubts found; using placeholder.');
        APPROVED_DOUBTS = [{ id:'p1', text:'(waiting for first approved doubt…)', date:new Date().toISOString().slice(0,10) }];
      }
      initializeDoubtPool();
    } catch(err){
      console.error(err);
      APPROVED_DOUBTS = [{ id:'p1', text:'(temporarily unable to load doubts)', date:new Date().toISOString().slice(0,10) }];
      initializeDoubtPool();
    } finally {
      boats = Array.from({length: BOAT_COUNT}, ()=> new Boat());
    }

    // Update counter on load
    try {
      const count = await fetchTotalDoubts();
      const counter = document.getElementById('doubt-counter');
      if (counter && count > 0) counter.textContent = `${count} doubts released`;
      else if (counter) counter.style.display = 'none';
    } catch {
      const counter = document.getElementById('doubt-counter');
      if (counter) counter.style.display = 'none';
    }
  })();
</script>

<script>
(() => {
  const header = document.querySelector('header.ripple');
  if (!header) return;

  const frames = [
    { opacity: 1, transform: 'translate3d(0,0,0) scale(1)', textShadow: '0 0 0 #fff' },
    { offset: 0.4, opacity: 0.35 },
    { offset: 0.5, opacity: 1, transform: 'translate3d(0.5em,0,0) scale(1.1)', textShadow: '0 0 20px #fff' },
    { offset: 0.75, opacity: 1, transform: 'translate3d(0,0,0) scale(1)', textShadow: '0 0 0 #fff' }
  ];

  const letters = [...header.children];
  const anims = letters.map((el, i) => {
    const a = el.animate(frames, { duration: 4000, fill: 'both', delay: i * 60 });
    a.pause();
    return a;
  });

  header.addEventListener('mouseenter', () => { anims.forEach(a => { a.playbackRate = 1; a.play(); }); });
  header.addEventListener('mouseleave', () => { anims.forEach(a => a.reverse()); });
})();
</script>

</body></html>
