<!DOCTYPE html>
<html lang="en"><head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Figtree:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Dongle&display=swap" rel="stylesheet">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>adrift</title>

<!-- Favicons -->
<link rel="icon" type="image/svg+xml" sizes="16x16" href="favicon-adrift-16x16.svg">
<link rel="icon" type="image/svg+xml" sizes="32x32" href="favicon-adrift-32x32.svg">
<link rel="shortcut icon" href="favicon-adrift-32x32.svg" type="image/svg+xml">

<style>
  :root{
    --paper-edge: #e8e3da;
    --paper-face: #e8e3da;
    --bloom-a: rgba(220, 211, 199, 0.40);
    --bloom-b: rgba(220, 211, 199, 0.40);
  }

  html, body { height:100%; }
  body { margin:0; background:#000; overflow:hidden; font-family: ui-sans-serif, system-ui; color:#ececed; }
  canvas { display:block; width:100%; height:100%; }

  /* Intro overlay */
  #intro-overlay {
    position: fixed;
    inset: 0;
    background: #000;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    opacity: 1;
    transition: opacity 1s ease-out;
    pointer-events: all;
  }
  
  #intro-overlay.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  
  .intro-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    max-width: 520px;
    gap: 20px;
  }

  #doubt-counter {
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 13px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(236, 236, 237, 0.6);
    opacity: 0;
    transform: translateY(8px);
    animation: introContentReveal 1.2s ease forwards;
    font-weight: 400;
  }

  #intro-text {
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 19.2px;
    line-height: 1.8;
    color: rgba(236, 236, 237, 0.85);
    max-width: 520px;
    margin: 0;
    opacity: 0;
    transform: translateY(8px);
    animation: introContentReveal 1.2s ease forwards;
    font-weight: 300;
    letter-spacing: 0.02em;
  }

  #intro-text.fade-out-text {
    animation: fadeOutText 1.5s ease-out forwards;
  }

  #intro-overlay .cta-btn {
    position: static;
    bottom: auto;
    z-index: auto;
  }

  .intro-enter-btn {
    opacity: 0;
    transform: translateY(16px);
    animation: introButtonRise 0.9s ease forwards;
    animation-delay: 1s;
  }

  @keyframes introContentReveal {
    from {
      opacity: 0;
      transform: translateY(14px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fadeOutText {
    to {
      opacity: 0;
    }
  }

  @keyframes introButtonRise {
    from {
      opacity: 0;
      transform: translateY(18px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Initially hide main content */
  .main-content {
    opacity: 0;
    transition: opacity 1.5s ease-in;
  }
  
  .main-content.visible {
    opacity: 1;
  }

  /* Layering: rain over boats (click-through), boats under notes */
  #rain  { position:fixed; inset:0; z-index:2; pointer-events:none; }
  #canvas{ position:fixed; inset:0; z-index:1; }

  header{ font-weight:400; position:fixed; top:18px; left:50%; transform:translateX(-50%); letter-spacing:0.25em; font-size:20px; font-family:"Dongle", ui-sans-serif, system-ui, sans-serif;text-transform:uppercase; text-align:center; user-select:none; z-index:5; }
  .hint{ font-weight:400; position:fixed; left:20px; bottom:16px; color:#9aa0a8; font-size:12px; opacity:.7; user-select:none; background: rgba(255,255,255,.03); letter-spacing: 0.05em; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.06); backdrop-filter: blur(3px); z-index:5; }

  /* Sound toggle */
  .sound-toggle{
    position:fixed; right:20px; bottom:16px; z-index:5;
    background: rgba(255,255,255,.03);
    color:#9aa0a8; font-size:12px; line-height:1;
    padding:8px 10px; border-radius:10px;
    border:1px solid rgba(255,255,255,.06);
    backdrop-filter: blur(3px);
    cursor:pointer; user-select:none;
    letter-spacing: 0.05em;
  }
  .sound-toggle.active{ color:#ececed; border-color: rgba(255,255,255,.12); }
  .sound-toggle:focus-visible{ outline:2px solid rgba(255, 200, 100, 0.25); outline-offset:2px; }

  /* Center-bottom CTA (kept) */
  .cta-btn{
    padding:28px 36px; border-radius:9999px; font-size:13px; line-height:1; color:#fff;
    letter-spacing: 0.05em;
    border:1px solid rgba(255,255,255,.28);
    background: rgba(255,255,255,.04);
    backdrop-filter: blur(3px);
    transition: box-shadow .25s ease, transform .2s ease, border-color .25s ease, background .25s ease;
    cursor:pointer; user-select:none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    white-space: nowrap;
  }

  .cta-btn--floating {
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px; z-index:5;
  }
  .cta-btn:hover{ box-shadow: 0 0 36px 12px rgba(255, 219, 90, 0.174), 0 0 8px 2px rgba(255,255,255,.25); border-color: rgba(255,255,255,.5); }
  .cta-btn:focus-visible{ outline:2px solid rgba(255, 200, 100, 0.35); outline-offset:3px; }

  /* Hidden media */
  #boatVideo, #bgAudio { position: fixed; left:-9999px; top:-9999px; width:1px; height:1px; opacity:0; pointer-events:none; }

  /* ===========================================================
     Unfolding NOTE (used for both boat view + composer)
     =========================================================== */
  .note-overlay { position: fixed; inset:0; z-index:6; pointer-events:none; }
  .overlay-close { position:fixed; inset:0; background: transparent; pointer-events:auto; }

  .note{
    position:absolute;
    width: min(350px, 90vw); 
    height: min(350px, 90vw);
    transform-style: preserve-3d; perspective: 800px;
    pointer-events:auto;
    filter: drop-shadow(0 12px 40px rgba(0,0,0,.55));
    transition: transform .35s ease, opacity .25s ease;
    cursor: grab;
    user-select: none; touch-action: none;
    will-change: left, top, opacity, transform;
    background: transparent;
  }
  .note.dragging{ cursor: grabbing; }
  .note.closing{ opacity:0; transform: scale(.98) translateZ(0); pointer-events:none; }

  /* FIXED: Circle close button for mobile */
  .note-close{
    position:absolute; top:10px; right:10px;
    width:28px; height:28px;
    border-radius:50%;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(12,14,18,.65);
    color:#fff; font-size:16px; line-height:1;
    border:1px solid rgba(255,255,255,.18);
    box-shadow:none;
    cursor:pointer;
    opacity:0; 
    pointer-events:none;
    transition: opacity .25s ease, transform .20s ease, background .2s ease, border-color .2s ease;
    z-index:3;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    text-align: center;
    transform: scale(.92) translateZ(0);
    -webkit-transform: scale(.92) translateZ(0);
  }
  .note.unfold .note-close{
    opacity:1; transform: scale(1) translateZ(0);
    transition-delay: 1.25s, 1.25s, 0s, 0s;
    pointer-events:auto;
  }
  .note-close:hover{ transform: scale(1.06) translateZ(0); background: rgba(12,14,18,.78); border-color: rgba(255,255,255,.28); }
  .note-close:active{ transform: scale(.98) translateZ(0); }
  .note-close:focus-visible{ outline:2px solid rgba(255, 180, 60, 0.5); outline-offset:2px; }

  .note-stage, .note-frame {
    position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    width:100%; height:100%;
  }
  .note-frame{
    opacity:0;
    box-shadow: 0 0 40px rgba(0,0,0,0.06);
    animation: note-show 0.5s 1s ease forwards;
  }

  .note-box{
    position:absolute;
    width:calc(50% - 25px); height:calc(50% - 25px);
    background: var(--paper-face);
    border: 25px solid var(--paper-edge);
    box-shadow: 0 0 40px rgba(0,0,0,0.07);
    overflow:hidden; border-radius:4px;
  }
  .note-box .note-in{
    position:absolute; width:100px; height:100px; border-radius:50%;
    background: transparent !important;
    animation: note-grow 0.5s 3s cubic-bezier(0.66,-0.30,0.66,1) forwards;
  }
  .note-box .one{ left:100px; bottom:-50px; }
  .note-box .two{ left:-50px;  bottom:-50px; }
  .note-box .thr{ left:100px; bottom:100px; }
  .note-box .fou{ left:-50px;  bottom:100px; }

  .note-box:nth-child(1){ border-right:none; border-bottom:none; border-radius: 5px 0 0 0; animation: note-clr 0.5s 0.5s ease forwards; }
  .note-box:nth-child(2){ left:50%; border-left:none; border-bottom:none; border-radius: 0 5px 0 0; transform-origin: 0 0; transform: rotateY(180deg); animation: note-fold 0.5s 0.5s ease forwards; }
  .note-box:nth-child(3){ top:50%; opacity:0; border-top:none; border-right:none; border-radius: 0 0 0 5px; transform: rotateX(180deg); transform-origin: 0 0; animation: note-fold2 0.5s 1s ease forwards; }
  .note-box:nth-child(4){ top:50%; left:50%; opacity:0; border-top:none; border-left:none; border-radius: 0 0 5px 0; transform: rotateX(180deg); transform-origin: 0 0; animation: note-fold2 0.5s 1s ease forwards; }

  .note-content{
    position:absolute; inset:22px 24px;
    display:flex; flex-direction:column; justify-content:flex-start;
    color:#0e1520; opacity:0; transform: translateY(4px);
    transition: opacity .45s ease 1.2s, transform .45s ease 1.2s;
    font-synthesis-weight:none;
    padding: 0;
    background: transparent;
  }
  .note.unfold .note-content{ opacity:1; transform: translateY(0); }

  .note-title{ font-size:11px; letter-spacing:.12em; text-transform:uppercase; color:#4c5562; margin-bottom:10px; }
  .note-text{ font-size:20px; line-height:1.55; color:#10151c; }
  .note-meta{ margin-top:14px; font-size:12px; color:#5a6472; }

  @keyframes note-clr { 0%, 100% { background: var(--paper-face); } }
  @keyframes note-fold { 0%, 99.99% { background: var(--paper-face); } 100% { background: var(--paper-face); transform: rotateY(360deg); } }
  @keyframes note-fold2 { 0%{opacity:1;background:var(--paper-face);} 25%{opacity:1} 40%{opacity:1} 100%{opacity:1;background:var(--paper-face);transform: rotateX(0deg);} }
  @keyframes note-show { to { opacity:1; } }

  /* Composer form bits (used inside .note-content) */
  .compose-field{ width:100%; min-height:110px; resize:vertical; box-sizing:border-box; border-radius:8px; border:1px solid rgba(0,0,0,.1); padding:10px 12px; font: 16px/1.5 ui-sans-serif, system-ui; color:#0e1520; background:#fff; }
  .compose-field:focus {
    outline: none;
    border-color: rgba(7, 7, 7, 0.4);
    box-shadow: 0 0 0 1px rgba(255, 180, 60, 0.15);
  }
  .compose-foot{ display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:12px; color:#4c5562; }
 .compose-disclaimer {
  font-size: 11px;
  color: rgba(16,21,28,0.55);
  text-align: center;
  margin-top: 64px;
}
  .pill-btn{ padding:12px 18px; border-radius:999px; border:1px solid rgba(0,0,0,.12); background:#0f172a; color:#fff; cursor:pointer; }
  .pill-btn:focus-visible {
    outline: 2px solid rgba(255, 180, 60, 0.5);
    outline-offset: 2px;
  }

  .note .compose-field { touch-action: auto; user-select: text; }
  .note .compose-foot button { touch-action: auto; }

/* --- Added: font smoothing, Figtree font, and ripple effect --- */
html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-rendering: optimizeLegibility; }

.figtree-adrift {
  font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
}

.dongle-regular {
  font-family: "Dongle", sans-serif;
  font-weight: 400;
  font-style: normal;
}


.ripple > * {
  display: inline-block;
  text-shadow: 0 0 0 #fff;
  color: transparent;
}

@keyframes rippleEffect {
  40% {
    opacity: .35;
  }
  50% {
    transform: translate3d(.5em, 0, 0) scale(1.1);
    text-shadow: 0 0 20px #fff;
  }
  75% {
    transform: translate3d(0, 0, 0) scale(1);
    text-shadow: 0 0 0 #fff;
    opacity: 1;
  }
}
/* --- end added --- */

/* --- Added: ensure header uses Figtree --- */
header.ripple span.figtree-adrift {
  font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
  font-weight: 700;
}
/* --- end added --- */

/* Mobile responsive styles */
@media (max-width: 640px) {
  .intro-content {
    max-width: 90vw;
    gap: 16px;
  }

  #doubt-counter {
    font-size: 12px;
    letter-spacing: 0.1em;
  }

  #intro-text {
    font-size: 16.8px;
    max-width: 90vw;
  }

  #intro-overlay .cta-btn {
    width: auto;
    padding: 20px 28px;
    align-self: center;
  }
  
  .note-content {
  inset: 21px 18px 16px 18px; /* Top padding increased to align with repositioned close button */
}
  
  .note-text {
    font-size: 18px; /* Smaller text */
  }
  
  .note-title {
    font-size: 10px;
  }
  
  .note-meta {
    font-size: 11px;
  }
  
  .cta-btn {
    padding: 20px 28px; /* Slightly smaller on mobile */
    font-size: 12px;
  }

  .cta-btn--floating {
    bottom: 70px;
  }
  
  header {
    font-size: 18px; /* Slightly smaller header on mobile */
  }
  
  /* Larger close button on mobile for better touch targets */
 .note-close {
  top: 6px; /* changed from 10px to 15px */
  width: 32px;
  height: 32px;
  font-size: 18px;
  min-width: 32px;
  min-height: 32px;
  max-width: 32px;
  max-height: 32px;
  /* Add these for better centering */
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  font-family: -apple-system, BlinkMacSystemFont, sans-serif; /* More consistent font */
  padding-bottom: 1px; /* Fine-tune vertical centering if needed */
  }
}


/* Landscape mobile - spread out bottom elements */
@media (max-height: 500px) and (orientation: landscape) {
  .hint { left: 10px; bottom: 10px;}
  .sound-toggle { right: 10px; bottom: 10px; }
  .cta-btn { padding: 16px 24px; }
  .cta-btn--floating { bottom: 16px; }
  header { top: 10px; }
}

/* For high-DPI displays (retina) */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .note-close {
    /* Force antialiasing for smoother circles */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    backface-visibility: hidden;
    transform-style: flat;
  }
}
</style>
</head>
<body class="figtree-adrift">
  <!-- Intro overlay -->
 <div id="intro-overlay">
    <div class="intro-content">
      <div id="doubt-counter" aria-live="polite" data-start-value="0">0 doubts released</div>
      <p id="intro-text">Adrift is a quiet space where doubts become paper boats and drift together across a shared sea.</p>
      <button id="enterBtn" class="cta-btn intro-enter-btn" type="button">Enter</button>
    </div>
  </div>

  <!-- Main content wrapper -->
  <div class="main-content">
    <header class="ripple"><span><span>a</span><span>d</span><span>r</span><span>i</span><span>f</span><span>t</span></span></header>

    <!-- media -->
    <video id="boatVideo" src="boat.mp4" loop="" muted="" playsinline="" preload="auto"></video>
    <audio id="bgAudio" src="sound.mp3" loop="" preload="auto"></audio>

    <!-- layers -->
    <canvas id="rain" aria-hidden="true"></canvas>
    <canvas id="canvas"></canvas>

    <div class="hint">Click boat to unfold</div>
    <button id="soundToggle" class="sound-toggle" aria-pressed="false" aria-label="Enable sound">Sound: Off</button>
    <button id="releaseBtn" class="cta-btn cta-btn--floating" aria-label="Release your doubt">Release your doubt</button>
  </div>

  <script src="./rain.js" defer=""></script>

<script>
  /* =====================
     Intro sequence
     ===================== */
  const introOverlay = document.getElementById('intro-overlay');
  const introText = document.getElementById('intro-text');
  const mainContent = document.querySelector('.main-content');
  const enterBtn = document.getElementById('enterBtn');
  const doubtCounter = document.getElementById('doubt-counter');

  function revealMainContent() {
    if (!introOverlay || introOverlay.classList.contains('fade-out')) return;
    if (introText) {
      introText.classList.add('fade-out-text');
    }
    introOverlay.classList.add('fade-out');
    if (mainContent) {
      mainContent.classList.add('visible');
    }
    setTimeout(() => {
      introOverlay.remove();
    }, 1200);
  }

  if (enterBtn) {
    enterBtn.addEventListener('click', () => {
      enterBtn.disabled = true;
      revealMainContent();
    });
  }

  /* =====================
     Supabase config (READ)
     ===================== */
  const SUPABASE_URL  = 'https://lrjpntpvcgzjhowrlmit.supabase.co';
  const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxyanBudHB2Y2d6amhvd3JsbWl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY0OTk4ODcsImV4cCI6MjA3MjA3NTg4N30.sDdezusu8bp6lBp6hmU6QnJVIz0Et4VHp5giEpUTa40';

async function fetchApprovedDoubts(limit = 500) {
  const url = `${SUPABASE_URL}/rest/v1/doubts?select=id,doubt,created_at&approved=is.true&order=created_at.desc&limit=${limit}`;
  const res = await fetch(url, {
    headers: {
      apikey: SUPABASE_ANON,
      Authorization: `Bearer ${SUPABASE_ANON}`,
      Accept: 'application/json'
    }
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Supabase fetch failed (${res.status}) ${text}`);
  }
  const rows = await res.json();
  return rows.map(r => ({
    id: r.id,
    text: r.doubt ?? '',
    date: (r.created_at || new Date().toISOString()).slice(0,10)
  })).filter(d => d.text && d.text.trim().length);
}

async function fetchTotalDoubts() {
  const url = `${SUPABASE_URL}/rest/v1/doubts?select=count&approved=is.true`;
  const res = await fetch(url, {
    headers: {
      apikey: SUPABASE_ANON,
      Authorization: `Bearer ${SUPABASE_ANON}`,
      Accept: 'application/json',
      Prefer: 'count=exact'
    }
  });
  if (!res.ok) return 0;
  return parseInt(res.headers.get('Content-Range')?.split('/')[1] || '0');
}

function animateDoubtCounter(el, targetValue) {
  if (!el) return;
  const finalValue = Math.max(0, targetValue);
  const startValue = Number(el.dataset.startValue || 0);
  const formatter = new Intl.NumberFormat();
  const formatValue = (value) => `${formatter.format(value)} doubt${value === 1 ? '' : 's'} released`;

  if (finalValue <= startValue) {
    el.textContent = formatValue(finalValue);
    el.dataset.startValue = String(finalValue);
    return;
  }

  let startTime;
  const duration = 1600;

  function step(timestamp) {
    if (startTime === undefined) startTime = timestamp;
    const progress = Math.min((timestamp - startTime) / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    const currentValue = Math.round(startValue + (finalValue - startValue) * eased);
    el.textContent = formatValue(currentValue);
    if (progress < 1) {
      requestAnimationFrame(step);
    } else {
      el.dataset.startValue = String(finalValue);
    }
  }

  requestAnimationFrame(step);
}

  /* ---------- n8n webhook (TEST URL now; switch to /webhook/… for prod) ---------- */
  const N8N_WEBHOOK_URL = 'https://alexmiretski.app.n8n.cloud/webhook/release-doubt';


  async function postDoubtToN8N(text){
    const res = await fetch(N8N_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });
    let data = {};
    try { data = await res.json(); } catch(e) {}
    if (!res.ok || data?.ok === false) {
      const msg = data?.error || `Request failed (${res.status})`;
      throw new Error(msg);
    }
    const d = Array.isArray(data) ? data[0] : data;
    return { id: d.id, created_at: d.created_at, doubt: d.doubt ?? text };
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha:true });
  const boatVideo = document.getElementById('boatVideo');
  const bgAudio = document.getElementById('bgAudio');
  const soundToggle = document.getElementById('soundToggle');
  const releaseBtn = document.getElementById('releaseBtn');

  let W, H;
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    W = innerWidth;  // Keep W and H as CSS pixels
    H = innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.scale(dpr, dpr); // Scale the context for crisp rendering
  }
  addEventListener('resize', resize);
  resize();

  /* ====== Media autoplay ====== */
const DEFAULT_VOL = 0.28;
function startAudio(){ bgAudio.volume = DEFAULT_VOL; bgAudio.play().then(()=> updateSoundUI(true)).catch(()=>{}); }
function updateSoundUI(on){ soundToggle.classList.toggle('active', !!on); soundToggle.setAttribute('aria-pressed', on ? 'true' : 'false'); soundToggle.textContent = on ? 'Sound: On' : 'Sound: Off'; }

let videoReady = false;
let videoRestartAttempts = 0;
const MAX_RESTART_ATTEMPTS = 2;

boatVideo.addEventListener('canplay', () => { 
  videoReady = true; 
  if(boatVideo.paused) boatVideo.play().catch(() => {}); 
}, {once: true});

function checkAndRestartVideo() {
  if (!videoReady && videoRestartAttempts < MAX_RESTART_ATTEMPTS) {
    console.warn(`Video not ready after timeout, attempting restart ${videoRestartAttempts + 1}/${MAX_RESTART_ATTEMPTS}`);
    videoRestartAttempts++;
    
    const currentSrc = boatVideo.src;
    boatVideo.src = '';
    boatVideo.load();
    boatVideo.src = currentSrc + '?t=' + Date.now();
    
    setTimeout(() => {
      boatVideo.play().catch(() => {
        console.error('Video restart failed');
      });
    }, 500);
    
    if (videoRestartAttempts < MAX_RESTART_ATTEMPTS) {
      setTimeout(checkAndRestartVideo, 8000);
    }
  }
}

// Start immediately, don't wait
boatVideo.play().catch(() => {});

// Monitor for failures
setTimeout(() => {
  if (!videoReady) {
    checkAndRestartVideo();
  }
}, 15000);

const ensurePlay = () => { 
  if (!videoReady) {
    console.log('User interaction - forcing video restart');
    checkAndRestartVideo();
  }
  boatVideo.play().catch(() => {}); 
  startAudio(); 
};
addEventListener('pointerdown', ensurePlay, {once:true}); 
addEventListener('keydown', ensurePlay, {once:true});
soundToggle.addEventListener('click', ()=>{ if(bgAudio.paused){ startAudio(); } else { bgAudio.pause(); updateSoundUI(false); } });
document.addEventListener('visibilitychange', ()=>{ if(!document.hidden && !bgAudio.paused){ bgAudio.play().catch(()=>{}); } });

  /* ===== Boats ===== */
  const CROP = {x:0, y:0, w:1, h:1};
  const BOAT_COUNT = window.innerWidth <= 640 ? 8 : 11, BOAT_HEIGHT=140;
  const SPEED_X=0.10, BOB_AMPL=12, BOB_FREQ=0.0016;

  const COLLISION_PAD = 15, PUSH_STRENGTH = 0.02, FRICTION = 0.34;

  // Perspective tuning
  const PERSPECTIVE_MIN_SCALE = 0.70;
  const PERSPECTIVE_MAX_SCALE = 1.35;
  const OPACITY_MIN = 0.35;
  const OPACITY_MAX = 0.95;

  // Holds fetched approved doubts and session tracking
let APPROVED_DOUBTS = [];
let USED_DOUBT_IDS = new Set(); // Track used doubts this session
let SHUFFLED_DOUBTS = []; // Pre-shuffled pool for current session

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function initializeDoubtPool() {
  // Create a shuffled copy of all approved doubts
  SHUFFLED_DOUBTS = shuffleArray(APPROVED_DOUBTS);
  USED_DOUBT_IDS.clear();
  console.log('Initialized shuffled doubt pool:', SHUFFLED_DOUBTS.length, 'doubts');
}

function pickRandomDoubt() {
  if (APPROVED_DOUBTS.length === 0) {
    // Safe placeholder if fetch returns nothing (or before it completes)
    return { text: "…", date: new Date().toISOString().slice(0,10), id: "placeholder" };
  }

  // If we've used all doubts, reinitialize the pool
  if (USED_DOUBT_IDS.size >= APPROVED_DOUBTS.length) {
    console.log('All doubts used, reshuffling pool');
    initializeDoubtPool();
  }

  // Find the next unused doubt from our shuffled pool
  let selectedDoubt = null;
  for (const doubt of SHUFFLED_DOUBTS) {
    if (!USED_DOUBT_IDS.has(doubt.id)) {
      selectedDoubt = doubt;
      USED_DOUBT_IDS.add(selectedDoubt.id);
      break;
    }
  }

  // Fallback (shouldn't happen with the logic above)
  if (!selectedDoubt) {
    selectedDoubt = SHUFFLED_DOUBTS[0];
    USED_DOUBT_IDS.add(selectedDoubt.id);
  }

  return selectedDoubt;
}


  async function refreshDoubtPool() {
  try {
    const freshDoubts = await fetchApprovedDoubts(600);
    if (freshDoubts.length > 0) {
      const oldLength = APPROVED_DOUBTS.length;
      APPROVED_DOUBTS = freshDoubts;
      
      // Only reinitialize if we got significantly more doubts
      if (freshDoubts.length > oldLength * 1.2) {
        initializeDoubtPool();
        console.log('Refreshed and reshuffled doubt pool:', APPROVED_DOUBTS.length, 'doubts');
      } else {
        console.log('Refreshed doubt pool:', APPROVED_DOUBTS.length, 'doubts');
      }
    }
  } catch (err) {
    console.error('Failed to refresh doubts:', err);
    // Keep using existing doubts if refresh fails
  }
}


  class Boat{
    constructor(){ this.reset(true); }
    reset(initial = false) {
      // Use canvas dimensions directly (no DPR scaling)
      this.yBase = Math.random() * H * 0.75 + H * 0.1;

      // ENTRY: start fully off-screen to the left (by half-width + 2px)
      const approxW = this._w || (BOAT_HEIGHT * 1.8);
      this.x = initial ? Math.random() * W : -(approxW * 0.5) - 2;

      this.phase = Math.random() * Math.PI * 2;
      this.alpha = 0.95;
      
      // Get a fresh doubt when resetting (now guaranteed unique per session)
      this.doubt = pickRandomDoubt();
      
      this._h = BOAT_HEIGHT;
      this._w = BOAT_HEIGHT * 1.8;
      this.vx = 0;
      this.vy = 0;
      this.highlightUntil = 0;
      this.paused = false;
      this.morphingIn = false;
      this.morphingOut = false;
      this.morphT0 = 0;
    }

    update(t, boats){
      const canMove = !(this.morphingOut);
      if(canMove){ 
        this.x += SPEED_X + this.vx; 
        if(this.x > W + (this._w||160)) this.reset(false); 
      }
      const bob = Math.sin(this.phase + t*BOB_FREQ) * BOB_AMPL; 
      this.y = this.yBase + bob + this.vy;

      const w = this._w || (BOAT_HEIGHT*1.8), h = this._h || BOAT_HEIGHT;
      for(const other of boats){
        if(other === this) continue;
        const ow = other._w || (BOAT_HEIGHT*1.8), oh = other._h || BOAT_HEIGHT;
        const halfW = w*0.5 + COLLISION_PAD, halfH = h*0.5 + COLLISION_PAD;
        const otherHalfW = ow*0.5 + COLLISION_PAD, otherHalfH = oh*0.5 + COLLISION_PAD;
        const dx = this.x - other.x, dy = this.y - other.y;
        const overlapX = (halfW + otherHalfW) - Math.abs(dx);
        const overlapY = (halfH + otherHalfH) - Math.abs(dy);
        if(overlapX > 0 && overlapY > 0){
          if(overlapX < overlapY){ 
            const dirX = Math.sign(dx) || (Math.random()<0.5 ? 1 : -1); 
            this.vx += dirX * overlapX * PUSH_STRENGTH; 
          }
          else { 
            const dirY = Math.sign(dy) || (Math.random()<0.5 ? 1 : -1); 
            this.vy += dirY * overlapY * PUSH_STRENGTH; 
          }
        }
      }
      this.vx *= FRICTION; 
      this.vy *= FRICTION;
    }
    draw(now){
      if(!videoReady) return;
      const vW=boatVideo.videoWidth||640, vH=boatVideo.videoHeight||360;
      const srcW=vW*CROP.w, srcH=vH*CROP.h, srcX=vW*CROP.x, srcY=vH*CROP.y;

      // PERSPECTIVE: scale & opacity by vertical position
      const yNorm = Math.max(0, Math.min(1, (this.y || this.yBase) / H));
      const scale = PERSPECTIVE_MIN_SCALE + (PERSPECTIVE_MAX_SCALE - PERSPECTIVE_MIN_SCALE) * yNorm;

      // Bottom 50% = full opacity; top 50% fades
      let a;
      if (yNorm >= 0.5) {
        a = 1;
      } else {
        const t = yNorm / 0.5;
        a = OPACITY_MIN + (1 - OPACITY_MIN) * t;
      }
      if(this.morphingOut) a = 0;
      if(a <= 0) return;

      const displayH = BOAT_HEIGHT * scale;
      const displayW = displayH * (srcW/srcH);
      this._w=displayW; this._h=displayH;

      ctx.save();
      ctx.translate(this.x, this.y);

      if(this.highlightUntil){
        const remaining = this.highlightUntil - performance.now();
        if(remaining > 0){
          const duration = 6000;
          const tFrac = Math.max(0, remaining/duration);
          const fade = 1 - (1 - tFrac) * (1 - tFrac);
          ctx.save();
          ctx.globalAlpha = fade;
          const g = ctx.createRadialGradient(0,0,10, 0,0,220);
          g.addColorStop(0,'rgba(255,240,160,.35)');
          g.addColorStop(0.35,'rgba(255,210,100,.18)');
          g.addColorStop(1,'rgba(255,210,100,0)');
          ctx.globalCompositeOperation='screen';
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2); ctx.fill();
          ctx.restore();
        } else {
          this.highlightUntil = 0;
        }
      }

      // FIXED: iOS-compatible blend mode rendering
      ctx.globalAlpha = a;
      
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      
      if(isIOS) {
        const dpr = window.devicePixelRatio || 1;
        const offCanvas = document.createElement('canvas');
        offCanvas.width = displayW * dpr;
        offCanvas.height = displayH * dpr;
        const offCtx = offCanvas.getContext('2d');
        offCtx.scale(dpr, dpr);
        offCtx.drawImage(boatVideo, srcX, srcY, srcW, srcH, 0, 0, displayW, displayH);
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(offCanvas, -displayW/2, -displayH/2, displayW, displayH);
        ctx.globalCompositeOperation = 'source-over';
      } else {
        const prev = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(boatVideo, srcX,srcY,srcW,srcH, -displayW/2, -displayH/2, displayW, displayH);
        ctx.globalCompositeOperation = prev;
      }
      
      ctx.restore();
    }
    hit(mx,my){ 
      return mx>=this.x-this._w/2 && mx<=this.x+this._w/2 && 
             my>=this.y-this._h/2 && my<=this.y+this._h/2; 
    }
  }

  // Will be filled after Supabase fetch
  let boats = [];

  // Also add a periodic refresh every 5 minutes
  setInterval(refreshDoubtPool, 5 * 60 * 1000);

  /* ===== Unfolding NOTE factory (boat + composer) ===== */
  let overlay=null, noteEl=null, noteBoat=null, noteClosing=false, composerOpen=false;

  const NO_DRAG_SELECTOR = 'textarea, input, select, button, a, [contenteditable="true"], .compose-field, .pill-btn, .note-close';

  function makeDraggable(el, size){
    let dragging=false, startX=0, startY=0, startLeft=0, startTop=0;
    const clamp=(v,min,max)=>Math.max(min, Math.min(max, v));

    el.addEventListener('pointerdown', (e)=>{
      if(e.button && e.button !== 0) return;
      if (e.target.closest(NO_DRAG_SELECTOR)) return;
      dragging = true;
      el.classList.add('dragging');
      el.setPointerCapture(e.pointerId);
      startX = e.clientX; startY = e.clientY;
      startLeft = parseFloat(el.style.left)||0;
      startTop  = parseFloat(el.style.top)||0;
      e.preventDefault();
    });

    el.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      let nextLeft = startLeft + dx, nextTop  = startTop  + dy;
      const maxL = innerWidth  - size, maxT = innerHeight - size;
      nextLeft = clamp(nextLeft, 0, Math.max(0, maxL));
      nextTop  = clamp(nextTop , 0, Math.max(0, maxT));
      el.style.left = nextLeft + 'px';
      el.style.top  = nextTop  + 'px';
    });

    const endDrag=(e)=>{
      if(!dragging) return;
      dragging = false;
      el.classList.remove('dragging');
      try{ el.releasePointerCapture(e.pointerId); }catch(_){}
    };
    el.addEventListener('pointerup', endDrag);
    el.addEventListener('pointercancel', endDrag);
    el.addEventListener('lostpointercapture', ()=>{ dragging=false; el.classList.remove('dragging'); });
  }

  function createNote({ x = null, y = null, title, bodyHTML, metaHTML, boat = null, startScale = 0.72 }) {
    overlay = document.createElement('div');
    overlay.className = 'note-overlay';
    overlay.innerHTML = `<div class="overlay-close" aria-hidden="true"></div>`;
    document.body.appendChild(overlay);

    noteEl = document.createElement('div');
    noteEl.className = 'note';

    // Responsive size
    const maxSize = Math.min(350, window.innerWidth * 0.9);
    const size = maxSize;
    const posX = (x ?? innerWidth / 2) - size / 2;
    const posY = (y ?? innerHeight / 2) - size / 2;

    noteEl.style.left = `${posX}px`;
    noteEl.style.top = `${posY}px`;
    noteEl.style.width = `${size}px`;
    noteEl.style.height = `${size}px`;
    noteEl.style.transformOrigin = 'center center';
    noteEl.style.transform = `scale(${startScale}) translateZ(0)`;

    const stage = document.createElement('div'); stage.className = 'note-stage';
    const frame = document.createElement('div'); frame.className = 'note-frame';
    noteEl.append(stage, frame);

    function makeBox(circleClass){
      const b = document.createElement('div'); b.className = 'note-box';
      const i = document.createElement('div'); i.className = 'note-in ' + circleClass;
      b.appendChild(i);
      return b;
    }
    stage.append(makeBox('one'), makeBox('two'), makeBox('thr'), makeBox('fou'));

    const content = document.createElement('div'); content.className='note-content';
    content.innerHTML = `
      <div class="note-title">${title}</div>
      ${bodyHTML}
      ${metaHTML||''}
    `;
    noteEl.appendChild(content);

    const closeBtn = document.createElement('button');
    closeBtn.className = 'note-close';
    closeBtn.setAttribute('aria-label','Close note');
    closeBtn.innerHTML = '&times;';
    closeBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
    closeBtn.addEventListener('click', (e)=>{ e.stopPropagation(); closeNote(); });
    closeBtn.addEventListener('transitionend', (e)=>{
      if(e.propertyName === 'opacity' && getComputedStyle(closeBtn).opacity === '1'){
        closeBtn.style.pointerEvents = 'auto';
      }
    });
    noteEl.appendChild(closeBtn);

    overlay.appendChild(noteEl);
    noteBoat = boat || null;

    makeDraggable(noteEl, size);

    requestAnimationFrame(()=>{
      noteEl.style.transform = 'scale(1) translateZ(0)';
      setTimeout(()=> noteEl.classList.add('unfold'), 140);
    });

    overlay.querySelector('.overlay-close').addEventListener('click', closeNote, {once:true});
  }

  function closeNote(){
    if(!noteEl || noteClosing) return;
    noteClosing = true;

    if(noteBoat){
      noteBoat.morphingIn = false;
      // Don't set morphingOut - let the boat continue floating
    }

    noteEl.classList.add('closing');

    const FINISH = ()=> {
      overlay?.remove(); overlay=null; noteEl=null;
      noteBoat = null; noteClosing = false; composerOpen = false;
    };

    let done=false;
    noteEl.addEventListener('transitionend', (e)=>{
      if(done || e.propertyName !== 'opacity') return;
      done=true; FINISH();
    }, {once:true});
    setTimeout(()=>{ if(!done) FINISH(); }, 280);
  }

  function openNoteFromBoat(boat){
    boat.morphingIn = true;
    boat.morphT0 = performance.now();
    const meta = `<div class="note-meta">${new Date(boat.doubt.date+'T00:00:00').toLocaleDateString(undefined,{year:'numeric',month:'long',day:'numeric'})}</div>`;
    const body = `<div class="note-text">${boat.doubt.text}</div>`;
    const maxSize = Math.min(350, window.innerWidth * 0.9);
    
    // Center notes on mobile devices (640px and below)
    const isMobile = window.innerWidth <= 640;
    const noteX = isMobile ? innerWidth / 2 : boat.x;
    const noteY = isMobile ? innerHeight / 2 : boat.y;
    
    createNote({ x:noteX, y:noteY, title:'Anonymous Doubt', bodyHTML:body, metaHTML:meta, boat, startScale:(boat._h/maxSize)*0.9 });
  }

  /* CTA → composer note */
  function openComposerNote() {
    composerOpen = true;

    const body = `
      <textarea class="compose-field" id="doubtInput" maxlength="200" placeholder="Type your doubt (200 characters max)"></textarea>
      <div class="compose-foot">
        <div><span id="charCount">0</span>/200</div>
        <button class="pill-btn" id="submitDoubt" type="button">Release</button>
      </div>
      <p class="compose-disclaimer">Offensive content will be flagged and removed.</p>
    `;

    createNote({
      x: innerWidth / 2,
      y: innerHeight / 2,
      title: 'Release your doubt',
      bodyHTML: body,
      metaHTML: '',
      boat: null,
      startScale: 0.72
    });

    const input = document.getElementById('doubtInput');
    const count = document.getElementById('charCount');
    const submit = document.getElementById('submitDoubt');

    input.addEventListener('input', () => {
      count.textContent = input.value.length;
    });
    setTimeout(() => input.focus(), 50);

    async function doRelease() {
      const text = (input.value || '').trim();
      if (!text) {
        input.focus();
        return;
      }

      submit.disabled = true;
      const prev = submit.textContent;
      submit.textContent = 'Releasing…';

      try {
        const { id, created_at, doubt } = await postDoubtToN8N(text);
        const b = new Boat();
        b.doubt = {
          text: doubt,
          date: (created_at || new Date().toISOString()).slice(0, 10),
          id
        };
        b.x = innerWidth / 2;
        b.yBase = innerHeight / 2;
        b.phase = 0;
        b.highlightUntil = performance.now() + 6000;
        boats.push(b);
        closeNote();
      } catch (err) {
        console.error('Release failed:', err);
        alert(err.message || 'Failed to release your doubt.');
      } finally {
        submit.disabled = false;
        submit.textContent = prev;
      }
    }

    submit.addEventListener('click', doRelease);
    input.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        doRelease();
      }
    });
  }

  /* Loop */
  function animate(now=0){ 
    ctx.clearRect(0,0,W,H); 

    // Update all first
    for(const b of boats){ 
      b.update(now, boats); 
    }

    // Draw sorted by y for proper layering (back-to-front)
    const byDepth = [...boats].sort((a,b)=> (a.y||a.yBase) - (b.y||b.yBase));
    for(const b of byDepth){
      b.draw(now);
    }

    requestAnimationFrame(animate); 
  }
  
  // Start animation immediately, don't wait for intro
  animate();

  /* Interactions */
  // Handle hover cursor
  canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    let overBoat = false;
    
    for(const b of boats){ 
      if(b.hit(mx,my) && !b.morphingOut){
        overBoat = true;
        break;
      }
    }
    
    canvas.style.cursor = overBoat ? 'pointer' : 'default';
  });
  
  canvas.addEventListener('click', e=>{
    if(composerOpen) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    for(const b of boats){ 
      if(b.hit(mx,my)){ 
        if(b.morphingOut) return; 
        openNoteFromBoat(b); 
        break; 
      } 
    }
  });
  releaseBtn.addEventListener('click', openComposerNote);
  addEventListener('keydown', e=>{ if(e.key==='Escape'){ closeNote(); } });

 /* =========
     Boot flow
     ========= */
  (async function init(){
try{
  APPROVED_DOUBTS = await fetchApprovedDoubts(600);
  if (APPROVED_DOUBTS.length === 0) {
    console.warn('No approved doubts found; using placeholder.');
    APPROVED_DOUBTS = [{ id:'p1', text:'(waiting for first approved doubt…)', date:new Date().toISOString().slice(0,10) }];
  }
  
  // Initialize the shuffled pool after loading doubts
  initializeDoubtPool();
  
} catch(err){
  console.error(err);
  // Soft fallback if Supabase is unreachable
  APPROVED_DOUBTS = [{ id:'p1', text:'(temporarily unable to load doubts)', date:new Date().toISOString().slice(0,10) }];
  initializeDoubtPool();
} finally {
  // Seed boats only after we have something to show
  boats = Array.from({length: BOAT_COUNT}, ()=> new Boat());
}

// Update counter on load
fetchTotalDoubts().then(count => {
  if (!doubtCounter) return;
  doubtCounter.style.visibility = 'visible';
  if (count > 0) {
    animateDoubtCounter(doubtCounter, count);
  } else {
    doubtCounter.textContent = '0 doubts released';
  }
}).catch(() => {
  if (doubtCounter) doubtCounter.style.visibility = 'hidden';
});
})();
</script>



<script>
(() => {
  const header = document.querySelector('header.ripple');
  if (!header) return;

  const frames = [
    { opacity: 1, transform: 'translate3d(0,0,0) scale(1)', textShadow: '0 0 0 #fff' },
    { offset: 0.4, opacity: 0.35 },
    { offset: 0.5, opacity: 1, transform: 'translate3d(0.5em,0,0) scale(1.1)', textShadow: '0 0 20px #fff' },
    { offset: 0.75, opacity: 1, transform: 'translate3d(0,0,0) scale(1)', textShadow: '0 0 0 #fff' }
  ];

  const letters = [...header.children];
  const anims = letters.map((el, i) => {
    const a = el.animate(frames, {
      duration: 4000,
      fill: 'both',
      delay: i * 60 // optional stagger
    });
    a.pause();
    return a;
  });

  header.addEventListener('mouseenter', () => {
    anims.forEach(a => { a.playbackRate = 1; a.play(); });
  });

  header.addEventListener('mouseleave', () => {
    anims.forEach(a => a.reverse());
  });
})();
</script>

</body></html>
